import numpy as np
import random
from scipy import constants
import matplotlib.pyplot as plt
import itertools
import copy
from time import sleep
import navier_stokes_cleaned as nsc
import os

year = 60. * 60. * 24. * 365.
dt_0 = year * 250000.
#properties for species in each SPH particle, (H2, He, H,H+,He+,e-,Mg2SiO4,SiO2,C,Si,Fe,MgSiO3,FeSiO3)in that order
species_labels = np.array(['H2', 'He', 'H','H+','He+','e-','Mg2SiO4','SiO2','C','Si','Fe','MgSiO3','FeSiO3'])
mu_specie = np.array([2.0159,4.0026,1.0079,1.0074,4.0021,0.0005,140.69,60.08,12.0107,28.0855,55.834,100.39,131.93])

TIMESTEP = 3e7 * year
MOLECULAR_CLOUD_DURATION = 3e7 * year
LOC_FRAC_CONSUMED = 0.005 * (TIMESTEP/MOLECULAR_CLOUD_DURATION)
FRAC_CONSUMED = (1. - LOC_FRAC_CONSUMED)**np.arange(10000) * LOC_FRAC_CONSUMED #probably way more timesteps than necessary
#fraction of galactic mass consumed by each cycle of GMCs, used to compute dilution of amounts calculated

'''
#### PURPOSE OF THIS CODE ####
 - Read in output files generated by each instance of code_running.py
 - Take the results and produce a new config file
 - Compute dust production from AGBs and use the derivative to compute dust added to new simulation
 - Output .npz files containing all the information needed (dust composition/fraction, gas composition, etc.)
 - Calculate cumulative change, divide by (MOLECULAR_CLOUD_DURATION/TIMESTEP) (longer timestep means more effect
   from each one).
   
#### SOME WORDS OF WARNING ####
 - Make sure that a 'config_00.npz' file already exists (create this manually or the code won't work!
 - Make sure that code forms a closed loop---i. e. code_running writes to small output files, and these
   small output files contain all the information asked for here, which in turn create config files, which
   in turn determine completely (up to randomness) the working of code_running.py. Code should be totally
   hands-off by the time it is run on supercomputer.
'''
 
absolute_path_to_nsc = os.path.dirname(os.path.abspath(nsc.__file__))
absolute_path_to_outputs = absolute_path_to_nsc + '/../savefiles/outputs'
absolute_path_to_config  = absolute_path_to_nsc + '/../savefiles/config'

config_files = os.listdir(absolute_path_to_config)
conf_number = np.array([am[7:-4] for am in config_files]).astype('int')
max_conf_file = (conf_number == max(conf_number))

TIMESTEP_NUMBER = max(conf_number)

conf_filename_selected = np.array(config_files)[max_conf_file][0]
latest_file = np.load(absolute_path_to_config + '/' + conf_filename_selected)

#Create array of AGB stars, loading in each file one at a time. This is a bit slow, but is most accurate.
timestep_AGB_list = np.array([])
timestep_AGB_time_until = np.array([])

timestep_gas_mass_by_species = copy.deepcopy(destruction_energies) * 0
timestep_star_mass_by_species = copy.deepcopy(destruction_energies) * 0
timestep_dust_mass_by_species = copy.deepcopy(destruction_energies) * 0

for savefile_name in os.listdir(absolute_path_to_outputs):
	array_file = np.load(savefile);
	AGB_list = array_file['AGB_list']
	AGB_time_until = array_file['AGB_time_until']
	
	timestep_AGB_list = np.append(timestep_AGB_list, AGB_list)
	timestep_AGB_time_until = np.append(timestep_AGB_time_until, AGB_time_until)
	
	timestep_gas_mass_by_species += array_file['gas_mass_by_species']
	timestep_star_mass_by_species += array_file['star_mass_by_species']
	timestep_dust_mass_by_species += array_file['dust_mass_by_species']
	
	array_file.close()

timestep_AGB_dust_prod = #SOME_FUNCTIONS_OF_MASS, match them up with time
#append these to overall_lists, found in latest file in output folder

#obtains DUST_FRAC, specie_fraction_array, and dust_base_frac from loaded output file
specie_fraction_array = latest_file['specie_fraction_array']
dust_base_frac = latest_file['dust_base_frac']
DUST_FRAC = latest_file['DUST_FRAC'] 
#find out how much dust is going to be produced OVER THE NEXT TIMESTEP and add it at the start
#assume changes in dust *during* each timestep are small, only total amounts matter. This is valid
#because only 0.5% of the galaxy's mass is subject to "processing" at any given time.
OVERALL_AGE = latest_file['OVERALL_AGE']

#rest of this is just handling dilution factors in mass vs. in number, need to make sure
#math is properly done there.

#increment OVERALL_AGE by TIMESTEP and write everything to the next output file


